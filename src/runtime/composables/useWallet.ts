import {
  Mnemonic,
  PrivateKey,
  XPrv,
  signMessage as wasmSignMessage,
  verifyMessage as wasmVerifyMessage,
  type HexString,
} from '../kaspa/kaspa'
import { WalletType } from '../types/enum'
import { useValidator } from './useValidator.client'

const DERIVE_PATH = `m/44'/111111'/0'/0/` // Default derivation path for Kaspa wallets

export const useWallet = () => {
  /**
   * Creates a new wallet instance from a mnemonic phrase.
   * @param {string} mnemonic - The mnemonic phrase.
   * @param {string} [password=""] - An optional password for additional security.
   */
  const fromMnemonic = (mnemonic: string, password: string = '') => {
    const seed = new Mnemonic(mnemonic).toSeed(password)
    const xprv = new XPrv(seed)
    const index = 0
    const privateKey = xprv.derivePath(`${DERIVE_PATH}${index}`).toPrivateKey()

    return {
      privateKey,
      walletType: WalletType.HD,
      xprv,
      index,
    }
  }

  /**
   * Creates a wallet instance from an existing private key.
   * @param {string} privateKey - The private key string.
   */
  const fromPrivateKey = (privateKey: string) => {
    return {
      privateKey: new PrivateKey(privateKey),
      walletType: WalletType.PrivateKey,
    }
  }

  /**
   * Creates a new wallet derived from the current HD wallet at a specified index.
   * @param {number} [index] - The index for the new wallet. If not provided, increments the last index.
   * @throws {Error} - Throws an error if the current wallet is not an HD wallet.
   */
  const create = (mnemonic: string, walletType: WalletType, index?: number) => {
    if (walletType !== WalletType.HD) {
      throw new Error(
        'A wallet created from a private key cannot derive new wallets.',
      )
    }

    // If index is not provided, increment the existing index.
    const newIndex = index ?? index! + 1

    const seed = new Mnemonic(mnemonic).toSeed()
    const xprv = new XPrv(seed)
    const privateKey = xprv
      .derivePath(`${DERIVE_PATH}${newIndex}`)
      .toPrivateKey()

    return {
      privateKey,
      walletType: WalletType.HD,
      xprv,
      index: newIndex,
    }
  }

  /**
   * Signs a given message using the private key.
   * This allows the owner of the private key to prove ownership of the associated address.
   *
   * @param message - The message to be signed.
   * @returns The signature as a hexadecimal string.
   */
  const signMessage = (message: string, privateKey: string): HexString => {
    return wasmSignMessage({ message, privateKey })
  }

  /**
   * Verifies a signed message using the public key.
   * This checks whether the signature was generated by the corresponding private key.
   *
   * @param message - The original message that was signed.
   * @param signature - The signature to be verified.
   * @returns A boolean indicating whether the signature is valid.
   */
  const verifyMessage = (
    message: string,
    signature: string,
    publicKey: string,
  ): boolean => {
    return wasmVerifyMessage({
      message,
      signature,
      publicKey,
    })
  }

  /**
   * Validates an address.
   * This checks whether the given address is valid using the AddressUtil.
   *
   * @param address - The address to be validated.
   * @returns A boolean indicating whether the address is valid.
   */
  const validate = (address: string): boolean => {
    return useValidator().validateAddress(address)
  }

  return {
    fromMnemonic,
    fromPrivateKey,
    create,
    signMessage,
    verifyMessage,
    validate,
  }
}
